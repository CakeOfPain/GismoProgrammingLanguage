int + int ::= $ADD($1, $2)
int - int ::= $SUB($1, $2)
int * int ::= $MUL($1, $2)
int / int ::= $DIV($1, $2)
int % int ::= $MOD($1, $2)
int >> int ::= $SHR($1, $2)
int << int ::= $SHL($1, $2)
int & int ::= $BWA($1, $2)
int | int ::= $BWO($1, $2)

float + float ::= $ADD($1, $2)
float - float ::= $SUB($1, $2)
float * float ::= $MUL($1, $2)
float / float ::= $DIV($1, $2)
float % float ::= $MOD($1, $2)

int + float ::= $ADD($1, $2)
float + int ::= $ADD($1, $2)
int - float ::= $SUB($1, $2)
float - int ::= $SUB($1, $2)
int * float ::= $MUL($1, $2)
float * int ::= $MUL($1, $2)
int / float ::= $DIV($1, $2)
float / int ::= $DIV($1, $2)

string + string ::= $CAT($1, $2)
string + int ::= $CAT($1, $2)
int + string ::= $CAT($1, $2)
string + symbol ::= $CAT($1, $QUOTE($2))
symbol + string ::= $CAT($QUOTE($1), $2)
int == int ::= {
    $EQUALS($1, $2)
}
string == string ::= $EQUALS($1, $2)
int > int ::= $GREATER($1, $2)
int < int ::= $GREATER($2, $1)
(-int) ::= $SUB(0, $1)
(+int) ::= $1
(-float) ::= $SUB(0, $1)
(+float) ::= $1
string(int) ::= $CHAR($1, $2)


$vector ::= $TYPEDEF(0, $vector)
$vector(*) ::= $FLATTEN($QUOTE($2), ",")

// VECTOR
Vector map (*) ::= {
      len ::= $VECTOR_LEN($1)
			f ::= $2
      newVector ::= $VECTOR(len)
			iterator ::= $LAMBDA(i, {
      	$IF($GREATER(len, i), {
        	element ::= $VECTOR_GET($1, i)
      		$VECTOR_SET(newVector, i, f(element))
        	iterator($ADD(i, 1))
      	}, {})
      })
      iterator(0)
			newVector
}

Vector join string ::= {
  len ::= $VECTOR_LEN($1)
  seperator ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF($GREATER(len, $ADD(i, 1)), {
        $CAT(element, $CAT(seperator, iterator($ADD(i, 1))))
      }, {
        element
      })
    }, "")
  })

  iterator(0)
}

Vector append (*) ::= {
     len ::= $VECTOR_LEN($1)
     $VECTOR_RESIZE($1, $ADD(len, 1))
     $VECTOR_SET($1, len, $2)
	   // RETURN:
		 $1
}

// FILTER
Vector filter (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = predicate function (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  newVector ::= $VECTOR(0)

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF(f(element), {
        // use the append operation to grow newVector
        newVector append element
      }, {})
      iterator($ADD(i, 1))
    }, {})
  })

  // Kick off iteration
  iterator(0)
  // Return the filtered result
  newVector
}

// FOREACH
Vector forEach (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = function to call for each element (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      f($VECTOR_GET($1, i))
      iterator($ADD(i, 1))
    }, {})
  })

  iterator(0)
  // Return original vector (or you could return nothing)
  $1
}

// SOME (returns true if ANY element passes the predicate)
Vector some (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = predicate function (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      $IF(f($VECTOR_GET($1, i)), {
        1
      }, {
        iterator($ADD(i, 1))
      })
    }, $NIL())
  })

  iterator(0)
}

// EVERY (returns true if ALL elements pass the predicate)
Vector every (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = predicate function (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      $IF(f($VECTOR_GET($1, i)), {
        iterator($ADD(i, 1))
      }, $NIL())
    }, 1)
  })

  iterator(0)
}

// INCLUDES (returns true if the vector contains the given value)
Vector includes (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = value to check for
  len ::= $VECTOR_LEN($1)
  value ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF($EQUALS(element, value), {
        1
      }, {
        iterator($ADD(i, 1))
      })
    }, $NIL())
  })

  iterator(0)
}

Vector indexOf (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = value to check for
  len ::= $VECTOR_LEN($1)
  value ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF($EQUALS(element, value), {
        i     // Match found: return current index
      }, {
        iterator($ADD(i, 1))
      })
    }, -1)    // End of vector reached: return -1 (not found)
  })

  iterator(0)
}

// ZIP (Combine two vectors into a vector of pairs)
Vector zip Vector ::= {
  // Args:
  //  $1 = First Vector (left side)
  //  $2 = Second Vector (right side)
  
  len1 ::= $VECTOR_LEN($1)
  len2 ::= $VECTOR_LEN($2)

  // Determine the shorter length (truncate to match)
  limit ::= $IF($GREATER(len1, len2), len2, len1)

  newVector ::= $VECTOR(limit)

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(limit, i), {
      // Use $CONS to create the pair [e1, e2]
      pair ::= $CONS($VECTOR_GET($1, i), $VECTOR_GET($2, i))

      $VECTOR_SET(newVector, i, pair)
      iterator($ADD(i, 1))
    }, {})
  })

  iterator(0)
  newVector
}

// COMPOSITE
$struct ::= $TYPEDEF(0, $struct)

$struct(*) ::= {
    fields ::= $FLATTEN($QUOTE($2), ",")
    $TYPEDEF(fields, metaStruct)
}

metaStruct(*) ::= {
    values ::= $FLATTEN($QUOTE($2), ",")
		interpredValues ::= values map $LAMBDA(x, $EVAL(x))
		fields ::= $UNTYPE($1)
		object ::= $CONS(fields, interpredValues)
    $TYPEDEF(object, metaObject)
}

metaObject.(*) ::= {
    fields ::= $CAR($UNTYPE($1))
    values ::= $CDR($UNTYPE($1))
    field ::= $QUOTE($2)

		len ::= $VECTOR_LEN(fields)

		finder ::= $LAMBDA(i, {
         $IF($GREATER(len, i), {
             element ::= $VECTOR_GET(fields, i)
             $IF($EQUALS(element, field), {
                 $VECTOR_GET(values, i)
             }, finder($ADD(i, 1)))
         }, $NIL())
    })
    
    finder(0)
}

$KEYWORD ::= $TYPEDEF($NIL(), $KEYWORD)
$KEYWORD(symbol) ::= {$EXPORT($2, $TYPEDEF($NIL(), $2))}

$NOT ::= $LAMBDA(x, $EQUALS(x, $NIL()))

$DEF($GLOBAL_STRINGS, $VECTOR(0))
$DECLARE_STRING ::= $LAMBDA(x, {
  str ::= x
  global_strings ::= $GET($GLOBAL_STRINGS)
  index ::= global_strings indexOf str
  $IF($EQUALS(index, -1), {
    i ::= $VECTOR_LEN(global_strings)
    $VECTOR_RESIZE(global_strings, i+1)
    $VECTOR_SET(global_strings, i, $CONS(str, i))
    i
  }, {
    index
  })
})


$LOAD("toolchain/types.gsm")
$LOAD("toolchain/language/main.gsm")