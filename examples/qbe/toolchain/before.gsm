int + int ::= $ADD($1, $2)
int - int ::= $SUB($1, $2)
int * int ::= $MUL($1, $2)
int / int ::= $DIV($1, $2)
int % int ::= $MOD($1, $2)
int >> int ::= $SHR($1, $2)
int << int ::= $SHL($1, $2)
int & int ::= $BWA($1, $2)
int | int ::= $BWO($1, $2)
string + string ::= $CAT($1, $2)
string + int ::= $CAT($1, $2)
int + string ::= $CAT($1, $2)
int == int ::= {
    $EQUALS($1, $2)
}
string == string ::= $EQUALS($1, $2)
int > int ::= $GREATER($1, $2)
int < int ::= $GREATER($2, $1)
(-int) ::= $SUB(0, $1)
(+int) ::= $1
string(int) ::= $CHAR($1, $2)


$vector ::= $TYPEDEF(0, $vector)
$vector(*) ::= $FLATTEN($QUOTE($2), ",")

// VECTOR
Vector map (*) ::= {
      len ::= $VECTOR_LEN($1)
			f ::= $2
      newVector ::= $VECTOR(len)
			iterator ::= $LAMBDA(i, {
      	$IF($GREATER(len, i), {
        	element ::= $VECTOR_GET($1, i)
      		$VECTOR_SET(newVector, i, f(element))
        	iterator($ADD(i, 1))
      	}, {})
      })
      iterator(0)
			newVector
}

Vector join string ::= {
  len ::= $VECTOR_LEN($1)
  seperator ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF($GREATER(len, $ADD(i, 1)), {
        $CAT(element, $CAT(seperator, iterator($ADD(i, 1))))
      }, {
        element
      })
    }, "")
  })

  iterator(0)
}

Vector append (*) ::= {
     len ::= $VECTOR_LEN($1)
     $VECTOR_RESIZE($1, $ADD(len, 1))
     $VECTOR_SET($1, len, $2)
	   // RETURN:
		 $1
}

// FILTER
Vector filter (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = predicate function (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  newVector ::= $VECTOR(0)

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF(f(element), {
        // use the append operation to grow newVector
        newVector append element
      }, {})
      iterator($ADD(i, 1))
    }, {})
  })

  // Kick off iteration
  iterator(0)
  // Return the filtered result
  newVector
}

// FOREACH
Vector forEach (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = function to call for each element (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      f($VECTOR_GET($1, i))
      iterator($ADD(i, 1))
    }, {})
  })

  iterator(0)
  // Return original vector (or you could return nothing)
  $1
}

// SOME (returns true if ANY element passes the predicate)
Vector some (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = predicate function (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      $IF(f($VECTOR_GET($1, i)), {
        true
      }, {
        iterator($ADD(i, 1))
      })
    }, false)
  })

  iterator(0)
}

// EVERY (returns true if ALL elements pass the predicate)
Vector every (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = predicate function (f)
  len ::= $VECTOR_LEN($1)
  f ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      $IF(f($VECTOR_GET($1, i)), {
        iterator($ADD(i, 1))
      }, false)
    }, true)
  })

  iterator(0)
}

// INCLUDES (returns true if the vector contains the given value)
Vector includes (*) ::= {
  // Args:
  //  $1 = originalVector
  //  $2 = value to check for
  len ::= $VECTOR_LEN($1)
  value ::= $2

  iterator ::= $LAMBDA(i, {
    $IF($GREATER(len, i), {
      element ::= $VECTOR_GET($1, i)
      $IF($EQUALS(element, value), {
        true
      }, {
        iterator($ADD(i, 1))
      })
    }, false)
  })

  iterator(0)
}

// COMPOSITE
$struct ::= $TYPEDEF(0, $struct)

$struct(*) ::= {
    fields ::= $FLATTEN($QUOTE($2), ",")
    $TYPEDEF(fields, metaStruct)
}

metaStruct(*) ::= {
    values ::= $FLATTEN($QUOTE($2), ",")
		interpredValues ::= values map $LAMBDA(x, $EVAL(x))
		fields ::= $UNTYPE($1)
		object ::= $CONS(fields, interpredValues)
    $TYPEDEF(object, metaObject)
}

metaObject.(*) ::= {
    fields ::= $CAR($UNTYPE($1))
    values ::= $CDR($UNTYPE($1))
    field ::= $QUOTE($2)

		len ::= $VECTOR_LEN(fields)

		finder ::= $LAMBDA(i, {
         $IF($GREATER(len, i), {
             element ::= $VECTOR_GET(fields, i)
             $IF($EQUALS(element, field), {
                 $VECTOR_GET(values, i)
             }, finder($ADD(i, 1)))
         }, $NIL())
    })
    
    finder(0)
}

$KEYWORD ::= $TYPEDEF($NIL(), $KEYWORD)
$KEYWORD(symbol) ::= {$EXPORT($2, $TYPEDEF($NIL(), $2))}

$NOT ::= $LAMBDA(x, $EQUALS(x, $NIL()))

$LOAD("toolchain/types.gsm")
$LOAD("toolchain/language.gsm")