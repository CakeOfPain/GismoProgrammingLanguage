
// Builtin Types
$LOAD("toolchain/language/types.gsm")

// Global Contants
symbol <- int ::= {
    $EXPORT($1, $2)
}

symbol <- string ::= {
    $EXPORT($1, $2)
}

symbol <- float ::= {
    $EXPORT($1, $2)
}

// <function name>(<no parameter>)
symbol() ::= {
    function_name ::= $1
    return_type ::= void
    arguments ::= $VECTOR(0)
    
    addr ::= function_name
    
    function_value ::= $Function(function_name, return_type, arguments, addr)
    function ::= $TYPEDEF(function, Function)
    function_prototype ::= $TYPEDEF(function_value, VoidFunctionProto, FunctionProto)

    $EXPORT(function_name, $UNION(function, function_prototype))

    // RETURN:
    function_prototype
}

// <function name>(<parameters>)
symbol(*) ::= {
    function_name ::= $1
    return_type ::= void
    
    // 1. Get the raw tokens
    raw_arguments ::= $FLATTEN($QUOTE($2), ",")
    
    // 2. Parse, Validate, and Transform arguments immediately
    arguments ::= raw_arguments map $LAMBDA(x, {
        T ::= $EVAL($CAR($CDR($CDR(x))))
        NAME ::= $EVAL($CAR($CDR(x)))

        // CHECK: Ensure T is a valid type immediately
        $IF($TYPEOF(T, "TYPE"), {}, $RAISE($2, $CAT("Expected a valid Type descriptor, not ", T)))

        // Transform into Variable object
        $Variable(NAME, T, $CAT("%", NAME))
    })
    
    addr ::= function_name
    
    // 3. Store the fully parsed arguments in the function value
    function_value ::= $Function(function_name, return_type, arguments, addr)
    function ::= $TYPEDEF(function, Function)
    function_prototype ::= $TYPEDEF(function_value, VoidFunctionProto, FunctionProto)

    $EXPORT(function_name, $UNION(function, function_prototype))

    // RETURN:
    function_prototype
}

VoidFunctionProto : (*) ::= {
    fn ::= $UNTYPE($1)
    type_descriptor ::= $2

    // Check that (*) is a valid type definition
    $IF($TYPEOF(type_descriptor, "TYPE"), {}, $RAISE($2, "Expected Type descriptor"))

    template_for_exporting_function ::= $QUOTE($EXPORT(NAME, $TYPEDEF(function, Function)))
    code_for_exporting_function ::= $REPLACE(template_for_exporting_function, "NAME", fn.name)
    $EVAL(code_for_exporting_function)

    // fn.arguments is already a list of checked $Variables here
    fn_value ::= $Function(fn.name, type_descriptor, fn.arguments, fn.addr)
    fn_prototype ::= $TYPEDEF(fn_value, FunctionProto)

    $EXPORT(fn.name, $UNION(fn_value, fn_prototype))

    // RETURN:
    fn_prototype
}

FunctionProto{*} ::= {
    functionProtoTyped ::= $1
    functionProto ::= $UNTYPE(functionProtoTyped)

    // Write "export function" if address is main, otherwise "function"
    $IF($EQUALS(functionProto.addr, "main"), 
        $WRITE("export function "), 
        $WRITE("function ")
    )
    

    $WRITE($UNTYPE(functionProto.returnType).nativeType)
    $WRITE(" $")
    $WRITE(functionProto.addr)
    $WRITE("(")

    // 4. Retrieve pre-parsed arguments
    mappedArgs ::= functionProto.arguments

    // Generate Signature
    $WRITE(mappedArgs map $LAMBDA(x, $CAT($UNTYPE(x.type).nativeType, $CAT(" ", x.addr))) join ", ")

    $WRITE(") {\n@start\n")

    _result ::= {
        // Define arguments as Values in Scope
        $FOREACH(mappedArgs, arg,
            $EVAL($REPLACE($REPLACE($QUOTE(S ::= $TYPEDEF($Value(arg.type, arg.addr), T)), S, arg.name), T, TYPE2TYPENAME(arg.type))))

        $LOAD("toolchain/language/infunction.gsm")
        
        {$2}
    }

    $WRITE("\n\tret ")

    $IF($TYPEOF(functionProtoTyped, VoidFunctionProto), {}, { // ELSE:
        $IF($EQUALS($UNTYPE($UNTYPE(functionProtoTyped).returnType).id, "void"), {}, { // ELSE:
            typeName ::= TYPE2TYPENAME($UNTYPE(functionProtoTyped).returnType)
            nativeType ::= TYPE2NATIVE($UNTYPE(functionProtoTyped).returnType)
            prefix ::= $UNTYPE($UNTYPE(functionProtoTyped).returnType).prefix

            isCorrectType ::= $EVAL($REPLACE($QUOTE($TYPEOF(_result, T)), T, typeName))
            isNativeType ::= $EVAL($REPLACE($QUOTE($TYPEOF(_result, T)), T, nativeType))

            $IF(isNativeType, {
                $WRITE($CAT(prefix, _result))
            }, $IF(isCorrectType, {
                $WRITE($UNTYPE(_result).addr)
            }, {
                $LAMBDA(x, {
                    $RAISE(x, "Function requires return value to match with the return type")
                })(functionProto.name)
            }))
        })
    })
    
    $WRITE("\n}\n")
}