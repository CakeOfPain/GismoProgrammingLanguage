// Buildin Types
i32 ::= $TYPEDEF("w", TYPE)

symbol <- int ::= {
    $EXPORT($1, $2)
}

symbol <- string ::= {
    $EXPORT($1, $2)
}

// <function name>(<no parameter>)
symbol() ::= {
    function_name ::= $1
    return_type ::= $TYPEDEF("", TYPE)
    arguments ::= $VECTOR(0)
    
    // REMOVED: Module prefix logic. Address is now just the function name.
    addr ::= function_name
    
    function_value ::= $Function(function_name, return_type, arguments, addr)
    function ::= $TYPEDEF(function, Function)
    function_prototype ::= $TYPEDEF(function_value, VoidFunctionProto, FunctionProto)

    $EXPORT(function_name, $UNION(function, function_prototype))

    // RETURN:
    function_prototype
}

// <function name>(<parameters>)
symbol(*) ::= {
    function_name ::= $1
    return_type ::= $TYPEDEF("", TYPE)
    arguments ::= $FLATTEN($QUOTE($2), ",")
    
    // REMOVED: Module prefix logic. Address is now just the function name.
    addr ::= function_name
    
    function_value ::= $Function(function_name, return_type, arguments, addr)
    function ::= $TYPEDEF(function_value, Function)
    function_prototype ::= $TYPEDEF(function_value, VoidFunctionProto, FunctionProto)

    $EXPORT(function_name, $UNION(function, function_prototype))

    // RETURN:
    function_prototype
}

VoidFunctionProto : (*) ::= {
    fn ::= $UNTYPE($1)
    type_descriptor ::= $2

    // Check that (*) is a valid type definition
    $IF($TYPEOF(type_descriptor, "TYPE"), {}, $RAISE("Error: Expected Type descriptor"))

    template_for_exporting_function ::= $QUOTE($EXPORT(NAME, $TYPEDEF(function, Function)))
    code_for_exporting_function ::= $REPLACE(template_for_exporting_function, "NAME", fn.name)
    $EVAL(code_for_exporting_function)

    fn_value ::= $Function(fn.name, type_descriptor, fn.arguments, fn.addr)
    fn_prototype ::= $TYPEDEF(fn_value, FunctionProto)

    $EXPORT(fn.name, $UNION(fn_value, fn_prototype))

    // RETURN:
    fn_prototype
}

FunctionProto{*} ::= {
    functionProtoTyped ::= $1
    functionProto ::= $UNTYPE(functionProtoTyped)

    // Write "export function" if address is main, otherwise "function"
    $IF($EQUALS(functionProto.addr, "main"), 
        $WRITE("export function "), 
        $WRITE("function ")
    )
    
    $WRITE($UNTYPE(functionProto.returnType))
    $WRITE(" $")
    $WRITE(functionProto.addr)
    $WRITE("(")

    mappedArgs ::= functionProto.arguments map $LAMBDA(x, {
        T ::= $EVAL($CAR($CDR($CDR(x))))
        NAME ::= $EVAL($CAR($CDR(x)))
        $IF($TYPEOF(T, "TYPE"), {}, $RAISE($CAT("Error: Expected a valid Type descriptor, not ", T)))

        $Variable(NAME, T, $CAT("%", NAME))
    })

    $WRITE(mappedArgs map $LAMBDA(x, $CAT($UNTYPE(x.type), $CAT(" ", x.addr))) join ", ")

    $WRITE(") {\n@start\n")

    _result ::= {
        // Definiere Argumente als Values im Scope
        $FOREACH(mappedArgs, arg, $EVAL($REPLACE($QUOTE(x ::= $TYPEDEF($Value(arg.type, arg.addr), VALUE_I32)), x, arg.name)))

        // +++ Definitions within Functions +++

        // Variable assignment from literal
        symbol <- int ::= {
            $WRITE("\t%")
            $WRITE($1)
            $WRITE(" =w copy ")
            $WRITE($2)
            $WRITE("\n")
            $EXPORT($1, $TYPEDEF($Value(i32, $CAT("%", $1)), VALUE_I32))
        }

        // Variable assignment from another Value (Aliasing)
        symbol <- VALUE_I32 ::= {
            value ::= $UNTYPE($2)
            $EXPORT($1, $TYPEDEF(value, VALUE_I32))
        }
        
        VALUE_I32 + int ::= {
            value ::= $UNTYPE($1)
            addr ::= $CAT("%t", $IOTA())

            $WRITE("\t")
            $WRITE(addr)
            $WRITE(" =w add ")
            $WRITE(value.addr)
            $WRITE(", ")
            $WRITE($2)
            $WRITE("\n")

            $TYPEDEF($Value(i32, addr), VALUE_I32)
        }

        int + VALUE_I32 ::= {
            value ::= $UNTYPE($2)
            addr ::= $CAT("%t", $IOTA())

            $WRITE("\t")
            $WRITE(addr)
            $WRITE(" =w add ")
            $WRITE($1)
            $WRITE(", ")
            $WRITE(value.addr)
            $WRITE("\n")

            $TYPEDEF($Value(i32, addr), VALUE_I32)
        }

        VALUE_I32 + VALUE_I32 ::= {
            value_a ::= $UNTYPE($1)
            value_b ::= $UNTYPE($2)
            addr ::= $CAT("%t", $IOTA())

            $WRITE("\t")
            $WRITE(addr)
            $WRITE(" =w add ")
            $WRITE(value_a.addr)
            $WRITE(", ")
            $WRITE(value_b.addr)
            $WRITE("\n")

            $TYPEDEF($Value(i32, addr), VALUE_I32)
        }

        // +++ Function Calls +++

        FunctionProto() ::= {
            fn_meta ::= $UNTYPE($1)
            $IF($EQUALS($VECTOR_LEN(fn_meta.arguments), 0), {}, $RAISE($CAT("Function ", $CAT(fn_meta.name, " expects arguments"))))

            retAddr ::= $CAT("%t", $IOTA())
            retTypeStr ::= $UNTYPE(fn_meta.returnType)

            $WRITE("\t")
            $WRITE(retAddr)
            $WRITE(" =")
            $WRITE(retTypeStr)
            $WRITE(" call $")
            $WRITE(fn_meta.addr)
            $WRITE("()\n")

            $TYPEDEF($Value(fn_meta.returnType, retAddr), VALUE_I32)
        }

        FunctionProto(*) ::= {
            fn_meta ::= $UNTYPE($1)
            given_args ::= $FLATTEN($QUOTE($2), ",") map $LAMBDA(x, $EVAL(x))

            $IF($EQUALS($VECTOR_LEN(fn_meta.arguments), $VECTOR_LEN(given_args)), {}, 
                $RAISE($CAT("Argument count mismatch for function ", fn_meta.name))
            )
            
            idx ::= 0

            formatted_args ::= fn_meta.arguments map $LAMBDA(arg_def, {
                expectedTypeObj ::= $EVAL($CAR($CDR($CDR(arg_def))))
                expectedTypeStr ::= $UNTYPE(expectedTypeObj)
                providedArg ::= $VECTOR_GET(given_args, idx)
                idx ::= idx + 1 

                argAddr ::= $IF($TYPEOF(providedArg, int), {
                    $IF($EQUALS(expectedTypeStr, "w"), {}, $RAISE("Type Mismatch: Function expects i32, got int literal"))
                    providedArg
                }, {
                    $IF($TYPEOF(providedArg, VALUE_I32), {
                        valObj ::= $UNTYPE(providedArg)
                        $IF($EQUALS(expectedTypeStr, "w"), {}, $RAISE("Type Mismatch: Function expects i32, got VALUE_I32"))
                        valObj.addr
                    }, {
                        $RAISE($CAT("Invalid argument type passed to ", fn_meta.name))
                    })
                })

                $CAT(expectedTypeStr, $CAT(" ", argAddr))
            })

            retAddr ::= $CAT("%t", $IOTA())
            retTypeStr ::= $UNTYPE(fn_meta.returnType)

            $WRITE("\t")
            $WRITE(retAddr)
            $WRITE(" =")
            $WRITE(retTypeStr)
            $WRITE(" call $")
            $WRITE(fn_meta.addr)
            $WRITE("(")
            $WRITE(formatted_args join ", ")
            $WRITE(")\n")

            $TYPEDEF($Value(fn_meta.returnType, retAddr), VALUE_I32)
        }
        
        {$2}
    }

    $WRITE("\n\tret ")
    $IF($NOT($TYPEOF(functionProtoTyped, VoidFunctionProto)), {
        $IF($TYPEOF(_result, int), {
            $WRITE(_result)
        }, $IF($TYPEOF(_result, VALUE_I32), {
            $WRITE($UNTYPE(_result).addr)
        }, {
            $RAISE("Function requires return type")
        }))
    }, {})

    $WRITE("\n}\n")
}